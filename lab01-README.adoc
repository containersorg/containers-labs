= Lab-01 - Monolithic vs Microservices Architectures

== Monolithic Architecture

Imagine a real-world scenario where we model a monolithic architecture for an application within a pharmaceutical company. In this simplified emulation, we'll conceptualize the application as running on a single server. For the sake of clarity, we will avoid delving into the intricacies of the actual code and instead focus on understanding the application's functionalities and the 'big picture' it presents.

image::pharmacy.png[200,200,align=center]

== Working Environment

Always begin projects by designating a dedicated directory to reside, in this repository the `monolithic` directory hosts our application.

This pharmacy application created in Python emulates the scenario of a pharmaceutical application on a single server running as a single service.

== Pharmacy Application Overview

Quick code explanation: This code is a mockup of an API application that receives requests to handle activities such as *placing orders*, *viewing inventory*, *viewing orders*, and *viewing customers* in a pharmacy system. Since this is a mockup, all the required data is hardcoded.

== Application Pre-requisites

Given that our application is developed in `Python` using the `FLASK` framework, our initial requirement is to have the `Python` language and the `pip` package manager installed to facilitate the installation of the `Flask` framework and the `requests` library.

[source,shell]
----
$ sudo dnf install -y python3
$ sudo dnf install -y pip
$ pip install --upgrade pip
$ pip install Flask
$ pip install requests
----

== Executing the Application

Within this monolithic framework, we consolidate all functionalities and other services encapsulated within a singular Flask application. This straightforward integration involves managing all operations within a single script.

Run the application with the following command:

[source,shell]
----
$ python3 pharmacy.py
----

While the application runs on notice is utilizes the port `5000`, also notice the Flask debugger currently occupies our terminal. Consequently, we need to open a new terminal to test the application through direct API calls using `CURL` commands.

image::mono.png[200,200,align=center]

== Testing the Application

Once the Flask web application is operational, it's usually accessible at the http://localhost:5000/ URL by default.

Tools such as Postman or CURL can be employed to send requests to various endpoints defined in the Flask application (e.g., `/place_order`, `/view_inventory`, `/view_orders`, `/view_customer/<customer_id>`).

NOTE: Keep in mind that this example involves running a basic Flask server locally solely for testing purposes. In a production environment, the application is typically deployed on a dedicated server and integrated with a database for robust data storage and management.

Initiate the testing phase with a straightforward direct call to our application:

[source,shell]
----
$ curl http://127.0.0.1:5000
Pharmacy v1
----

While we can confirm that the application is responsive, the passed instruction only prints the version.

Try again, this time focusing on verifying the inventory:

[source,shell]
----
$ curl http://127.0.0.1:5000/view_inventory

{
  "inventory": {
    "medicine_A": {
      "price": 10,
      "stock": 100
    },
    "medicine_B": {
      "price": 15,
      "stock": 50
    }
  }
}
----

Making direct calls to an API is a straightforward process. Now, leverage the `view_customer` function to retrieve and display information about our customers:

[source,shell]
----
$ curl http://127.0.0.1:5000/view_customer/customer_id_1
{
  "customer_details": {
    "address": "123 Main St",
    "name": "John Doe"
  }
}

$ curl http://127.0.0.1:5000/view_customer/customer_id_2
{
  "customer_details": {
    "address": "456 Elm St",
    "name": "Alice Smith"
  }
}
----

Attempt to display our active orders, although we are aware that they are currently empty:

[source,shell]
----
$ curl http://127.0.0.1:5000/view_orders

{
  "orders": []
}
----

Proceeding to introduce an order into the system. If we carefully examine our application code, we'll observe that order placement utilizes the POST method.

[source,shell]
----
$ curl -X POST \
    -H "Content-Type: application/json" \
    -d '{"customer_id": "customer_id_1", "medicine": "medicine_A", "quantity": 5}' \
    http://localhost:5000/place_order

{
  "message": "Order placed successfully",
  "order_details": {
    "customer_id": "customer_id_1",
    "medicine": "medicine_A",
    "quantity": 5,
    "status": "Pending",
    "total_price": 50
  }
}
----

Consequently, we can retrieve and display our active orders once again:

[source,shell]
----
$ curl http://127.0.0.1:5000/view_orders

{
  "orders": [
    {
      "customer_id": "customer_id_1",
      "medicine": "medicine_A",
      "quantity": 5,
      "status": "Pending",
      "total_price": 50
    }
  ]
}
----

In a more realistic scenario, our application will feature a distributed architecture with high availability and resilience capabilities, utilizing multiple databases and servers to host different components of the solution.

image::mono-servers.png[600,600,align=center]

== Terminating the Application

Before continuing, ensure the termination of the monolithic application running on port `5000` by using the (`CTRL+C`) key combination in the first opened terminal where the Flask application is currently attached.
