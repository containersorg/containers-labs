= Lab 8 - Making Data Persistent (Volumes)
:tip-caption: üí° TIP
:warning-caption: ‚ö†Ô∏è WARNING

The engineering team has a new requirement: ensure that customer order data is stored persistently, so that even if the Order Service is restarted or crashes, the data is not lost.

To achieve this, the `order_service.py` has been modified to store orders in a file-based database (JSON file) located at the path defined by the constant `ORDERS_FILE` which is set to **/data/orders.json**.

This persistence mechanism relies on three steps: read existing orders from the file, update orders, and write changes back to the file.

== 1. Debugging the Missing Directory

Since we have new code, we need to rebuild the images and create new containers.

=== Build and Run Initial V3

First, we build the initial V3 image. We will run it without the `--rm` option so the failed container remains in the system for inspection.

[source,shell]
----
$ podman build -t pharmacy:v3 .

# Stop and Remove any existing containers
$ podman rm -f inventory_service customer_service billing_service order_service

# Run all four services using the new image
$ podman run --name order_service --network host -d localhost/pharmacy:v3 order_service.py
$ podman run --name inventory_service --network host -d localhost/pharmacy:v3 inventory_service.py
$ podman run --name customer_service --network host -d localhost/pharmacy:v3 customer_service.py
$ podman run --name billing_service --network host -d localhost/pharmacy:v3 billing_service.py
----

We check the container status:

[source,shell]
----
$ podman ps -a
----

Notice that the `order_service` container is not running as expected. The container is in an **Exited (1)** status, indicating an application failure.

== Inspect Logs for Cause

Let's find out why the application crashed by checking the container logs:

[source,shell]
----
$ podman logs order_service
Traceback (most recent call last):
  File "//order_service.py", line 12, in <module>
    with open(ORDERS_FILE, 'w') as f:
    ^^^^^^^^^^^^^^^^^^^^^^
FileNotFoundError: [Errno 2] No such file or directory: '/data/orders.json'
----

TIP: The error shows the application failed because it tried to open the file `/data/orders.json`, but the **`/data` directory itself does not exist** in the image's filesystem, causing a `FileNotFoundError`.

== 2. Fixing the Image with the `/data` Directory

We must add the `/data` directory to our image by modifying the `Containerfile` and rebuilding.

.Containerfile (V4 - Directory Fix)
[source,dockerfile]
----
include::solution/Containerfile[]
----

=== Rebuild and Relaunch V4

Once again, build the image (version 4).

[source,shell]
----
$ podman build -t pharmacy:v4 .
$ podman rm order_service # Remove the old, failed container
$ podman run --name order_service --network host -d localhost/pharmacy:v4 order_service.py
---

== Test the Application Write Function

The service should now be running. Let's test the service by placing an order.

[source,shell]
----
  # 1. Place a new order

$ curl -X POST \
    -H "Content-Type: application/json" \
    -d '{"customer_id": "customer_id_1", "medicine": "medicine_A", "quantity": 5}' \
    http://localhost:5002/place_order

  # 2. Verify the order was successfully added and read back

$ curl http://127.0.0.1:5002/view_orders

  # 3. Check the file inside the container's filesystem

$ podman exec -ti order_service cat /data/orders.json
[
  {
    "customer_id": "customer_id_1",
    # ... order data saved to the file inside the container ...
  }
]
----

The order data is now saved to the file within the container's writable layer.

== 3. Enabling External Persistence with Volumes

The data is currently saved on the container's writable layer. If we stop and remove the container (using `--rm`), we lose the data. To achieve true persistence across container restarts, we must convert the `/data` folder into a **Volume**.

=== Create the Volume

Create a named volume on the host system. This is a dedicated, host-managed storage area.

[source,shell]
----
$ podman volume create pharmacy_orders_data
$ podman volume inspect pharmacy_orders_data | grep Mountpoint
          "Mountpoint": "/home/username/.local/share/containers/storage/volumes/pharmacy_orders_data/_data",
----

NOTE: The `Mountpoint` is the actual directory on your host machine where the data will be stored permanently.

=== Rerun the Container with Volume Mount

Stop the current container and relaunch it using the volume. We use the `-v` flag to map the host volume to the container's internal `/data` directory.

[source,shell]
----
$ podman stop order_service
$ podman rm order_service
$ podman run --rm --name order_service --network host \
    -v pharmacy_orders_data:/data:rw \
    -d localhost/pharmacy:v4 order_service.py
----

=== Final Persistence Test

Place one new order and then stop the container to prove the data persists externally.

[source,shell]
----
  # Place a new order (this data is written to the host volume)

$ curl -X POST \
    -H "Content-Type: application/json" \
    -d '{"customer_id": "customer_id_2", "medicine": "medicine_B", "quantity": 10}' \
    http://localhost:5002/place_order

  # Retrieve the host mountpoint path (replace 'username' with your actual username)

$ HOST_VOLUME_PATH=$(podman volume inspect pharmacy_orders_data --format '{{ .Mountpoint }}')

  # Check the file contents directly from the host system

$ cat $HOST_VOLUME_PATH/orders.json
[
  {
    "customer_id": "customer_id_1",
    # ... first order data ...
  },
  {
    "customer_id": "customer_id_2",
    # ... second order data ...
  }
]
----

Excellent! The data is now fully persistent. If the container is stopped or deleted, we can simply restart it using the same volume, and the data will be retained.

== 4. Terminating the Lab

[source,shell]
----
$ podman stop -a
----
