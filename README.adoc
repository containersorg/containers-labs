= Lab 9 - Isolate the Application

Until now, we have been using the host network when running containers to remove isolation between containers and utilize the host network, thereby avoiding the need to deal with ports and other network-related configurations.

This time, let’s use a different approach. Let’s create a network specifically for our application to work in isolation from the hosts but not from the components of the application itself.

Create a network:

[source,shell]
----
$ podman network create pharmacy
$ podman network inspect pharmacy
----

Now, since the source code of our application currently attempts to use the host network, Flask binds to localhost (127.0.0.1) by default, and therefore it will only be reachable from within the container or another container within the same subnet. But want to reach it from the local machine (host), we need Flask to bind to all IPs:

So we will change the line on each Python script as follows:

[source,python]
----
# On billing_service.py
    app.run(host='0.0.0.0',port=5004)
# On customer_service.py
    app.run(host='0.0.0.0',port=5003)
# On order_service.py
    app.run(host='0.0.0.0',port=5002)
# On inventory_service.py
    app.run(host='0.0.0.0',port=5001)
----

*Why Change the Code to host='0.0.0.0'?*

In our Python scripts, we added (host='0.0.0.0') to the app.run() call. This is a crucial change when moving from the host network to an isolated bridge network with port mapping.

- By default, Flask binds to 127.0.0.1 (localhost). This means the application will only accept connections that originate from inside its own network namespace.
- Binding to 0.0.0.0 (All Interfaces) tells the application to accept connections on all of its available network interfaces.

When we use port mapping (e.g., -p 5001:5001), Podman forwards traffic from the host into the container's isolated network. For our application inside the container to receive this forwarded traffic, it must be listening on 0.0.0.0.

Build version 5 of our application

[source,shell]
----
$ podman build -t pharmacy:v5 .
----

Create the containers using the latest version:

[source,shell]
----
$ podman run --rm --name inventory_service --network pharmacy -p 5001:5001 -d localhost/pharmacy:v5 inventory_service.py
$ podman run --rm --name customer_service --network pharmacy -p 5003:5003  -d localhost/pharmacy:v5 customer_service.py
$ podman run --rm --name billing_service --network pharmacy -p 5004:5004  -d localhost/pharmacy:v5 billing_service.py
$ podman run --rm --name order_service --network pharmacy -v data:/data:rw -p 5002:5002  -d localhost/pharmacy:v5 order_service.py
----

Test the service:

[source,shell]
----
$ ansible-playbook play.yml
----

We have a fully isolated application running on its own network with persistent storage and a fully functional application.
