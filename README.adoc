= Lab 6 - A More Automated Approach (Containerfiles)
:tip-caption: ðŸ’¡ TIP
:warning-caption: âš ï¸ WARNING

Up to this point, our approach has been implemented *manually*. This is not efficient, as the only way to repeat the process is to manually execute dozens of shell commands.

We will now use **Containerfiles** (sometimes called Dockerfiles) to automate the entire process. A Containerfile is a text file containing declarative instructions for building an image.

== The Declarative Approach

Notice how each `Containerfile` is an automated replica of the manual steps we performed in Lab 3:

1.  Installing dependencies (`RUN dnf install...`)
2.  Copying the source code (`COPY...`)
3.  Defining the startup command (`CMD...`)

.Containerfile_inventory_service
[source,dockerfile]
----
FROM fedora
RUN dnf install -yqq python3 python3-pip python3-requests
COPY inventory_service.py .
CMD ["python3", "inventory_service.py"]
----

> ... other Containerfiles follow the same structure and pattern ...

You can observe them all with the following command:

[source,shell]
----
$ tail Containerfile_*
----

== 1. Building the Images Automatically

To build these images, navigate to the microservices directory and run the following commands.

[source,shell]
----
$ podman build -t inventory-service -f Containerfile_inventory_service .
$ podman build -t order-service -f Containerfile_order_service .
$ podman build -t customer-service -f Containerfile_customer_service .
$ podman build -t billing-service -f Containerfile_billing_service .
----

TIP: Did you notice how fast the building process was after the first image? Since images are built in layers, the repetitive steps (`FROM fedora`, `RUN dnf install...`) are **cached** and do not have to be processed again. This is a core efficiency of containerization.

=== Verification of Built Images

[source,shell]
----
$ podman image ls | grep '-service'
localhost/billing-service                     latest      2c6c35332f5d  26 seconds ago  349 MB
localhost/customer-service                    latest      bc7b8e8194ae  31 seconds ago  349 MB
localhost/order-service                       latest      b59b952e73d2  36 seconds ago  349 MB
localhost/inventory-service                   latest      981e3a973de3  44 seconds ago  349 MB
----

== 2. Deploying Services from Containerfiles

Since we defined a `CMD` instruction in each `Containerfile`, we no longer need to specify the `python3 service.py` command manually when running the container. The image already knows what command to execute.

=== Stop Previous Containers

WARNING: Ensure the containers from Lab 5 are stopped to free up ports 5001-5004.

[source,shell]
----
$ podman stop -a
----

=== Launch the Services (Using Automatic CMD)

Run all four containers using the images we just built. The `podman run` command is now cleaner and shorter:

[source,shell]
----
$ podman run --name inventory_service --network host -d localhost/inventory-service
$ podman run --name order_service --network host -d localhost/order-service
$ podman run --name customer_service --network host -d localhost/customer-service
$ podman run --name billing_service --network host -d localhost/billing-service
----

Verify that all four services are running:

[source,shell]
----
$ podman ps
----

== 3. Testing the Automated Deployment

The application should function identically, but the process is now **repeatable and standardized**. We confirm inter-service communication (Order $\rightarrow$ Inventory) is working.

=== Cross-Service Validation (Order Placement)

Use a free terminal to place and verify an order.

[source,shell]
----
# 1. Place a test order, targeting port 5002
$ curl -X POST \
    -H "Content-Type: application/json" \
    -d '{"customer_id": "customer_id_1", "medicine": "medicine_A", "quantity": 5}' \
    http://localhost:5002/place_order

# 2. Verify the order exists by querying the Order Processing Service
$ curl http://127.0.0.1:5002/view_orders
----

== 4. Terminating the Lab

WARNING: Terminate the services before concluding the module.

[source,shell]
----
$ podman stop -a
----